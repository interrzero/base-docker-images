# .github/workflows/daily-scan-rebuild.yml
name: Vulnerability Scan and Rebuild

on:
  schedule:
    # Runs daily at 10:00 UTC (5 AM EST / 6 AM EDT)
    - cron: '0 10 * * *'
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if within cooldown period'
        required: false
        default: false
        type: boolean
      ignore_cooldown:
        description: 'Ignore cooldown period (for emergencies)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  GH_REPO: ${{ github.repository }}
  TRIGGER_SEVERITIES: "CRITICAL,HIGH,MEDIUM"
  # Cooldown periods in hours - don't rebuild if last release was within this time
  REBUILD_COOLDOWN_HOURS: "24"  # 1 day (daily rebuilds for both language and non-language)
  CRITICAL_COOLDOWN_HOURS: "0"  # No cooldown for CRITICAL vulnerabilities

jobs:
  scan_and_rebuild:
    runs-on: ubuntu-latest
    permissions:
      contents: write    # Needed to push new tags
      packages: read     # Needed to pull images and inspect manifests
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0 # Required to list tags

      - name: Discover available base images
        id: discover_images
        run: |
          BASE_NAMES=$(find . -maxdepth 1 -name 'Dockerfile.*' -type f -printf '%f\n' | sed 's/^Dockerfile\.//' | sort -u | paste -sd ' ')
          if [ -z "$BASE_NAMES" ]; then
            echo "::error::No Dockerfiles found matching 'Dockerfile.*'"
            exit 1
          fi
          echo "Discovered image base names: $BASE_NAMES"
          echo "IMAGE_BASE_NAMES=$BASE_NAMES" >> $GITHUB_ENV

      - name: Setup Docker environment
        uses: ./.github/actions/setup-docker
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Trivy scanner
        run: |
          # Install Trivy and jq for vulnerability scanning
          sudo apt-get update && sudo apt-get install -y jq
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

      - name: Scan images and determine rebuild requirements
        id: scan_check_rebuild
        run: |
          set -e # Exit on most errors, but parsing/scan failures handled below

          dockerfile_has_changed() {
            local image=$1
            local dockerfile="Dockerfile.$image"
            local latest_tag=$(git for-each-ref --sort='-v:refname' --format '%(refname:short)' refs/tags/release/$image | head -n 1)

            if [ -z "$latest_tag" ]; then
              # No previous tag, so it has definitely "changed"
              return 0
            fi

            if ! git diff --quiet $latest_tag HEAD -- "$dockerfile"; then
              # The file has changed
              return 0
            else
              # The file has not changed
              return 1
            fi
          }

          needs_rebuild_list=""

          if [ -z "$IMAGE_BASE_NAMES" ]; then
              echo "::error::IMAGE_BASE_NAMES environment variable is not set. Discovery might have failed."
              exit 1
          fi
          echo "Processing image base names: $IMAGE_BASE_NAMES"

          for base_name in $IMAGE_BASE_NAMES; do
            echo "=== Processing image base name: $base_name ==="
            found_fixable_vulns_for_base=false
            rebuild_reason=""

            for platform_suffix in linux-amd64 linux-arm64; do
              image_name="${base_name}-${platform_suffix}"
              full_image_tag="${{ env.REGISTRY }}/${{ env.GH_REPO }}/${image_name}:latest"

              echo "Checking image: $full_image_tag"

              # Check if image exists before scanning
              if ! docker manifest inspect "$full_image_tag" > /dev/null 2>&1; then
                echo "::warning::Image $full_image_tag not found in registry. Skipping scan for this platform."
                continue # Skip to next platform
              fi

              echo "Scanning $full_image_tag for vulnerabilities (severities: ${{ env.TRIGGER_SEVERITIES }})"
              # Run Trivy vulnerability scan
              if trivy image \
                --ignore-unfixed \
                --exit-code 1 \
                --severity ${{ env.TRIGGER_SEVERITIES }} \
                --format table \
                "$full_image_tag"; then
                echo "‚úÖ No fixable vulnerabilities found in $full_image_tag"
              else
                scan_exit_code=$?
                if [ $scan_exit_code -eq 1 ]; then
                  echo "‚ö†Ô∏è  Fixable vulnerabilities found in $full_image_tag"
                  found_fixable_vulns_for_base=true
                else
                  echo "‚ùå Trivy scan failed for $full_image_tag (exit code: $scan_exit_code)"
                  # Continue processing other platforms
                fi
              fi
            done # End platform loop

            # Check if we need to rebuild based on vulnerabilities + base image freshness
            if [ "$found_fixable_vulns_for_base" = true ]; then
              echo "üîç Vulnerabilities found for $base_name. Checking base image freshness..."
              dockerfile="Dockerfile.$base_name"
              if [ ! -f "$dockerfile" ]; then
                echo "::error::Dockerfile $dockerfile not found. Cannot check base image. Skipping rebuild trigger for $base_name."
                continue # Skip to next base_name
              fi

              # Extract base image information from Dockerfile
              from_line=$(grep -i '^FROM' "$dockerfile" | head -n 1)
              echo "Parsing FROM line: $from_line"

              # Extract image name and SHA from FROM line
              from_image_name=$(echo "$from_line" | sed -E -n 's/^FROM\s+([^@]+)@sha256:.*/\1/p')
              current_sha_with_prefix=$(echo "$from_line" | sed -E -n 's/.*(@sha256:[a-f0-9]{64}).*/\1/p')

              # Trim whitespace
              from_image_name=$(echo "$from_image_name" | xargs)

              if [ -n "$from_image_name" ] && [ -n "$current_sha_with_prefix" ]; then
                current_sha_digest="${current_sha_with_prefix#@}" # Remove the '@' prefix
                echo "Dockerfile uses base image: [$from_image_name] with SHA: [$current_sha_digest]"

                echo "Querying registry for latest digest of [$from_image_name]..."
                if latest_sha_digest=$(docker manifest inspect "$from_image_name" | jq -r 'if type == "array" then .[0].digest else (.manifests[0].digest // .config.digest // .digest) end // empty'); then
                  if [ -n "$latest_sha_digest" ]; then
                    echo "Latest digest found: [$latest_sha_digest]"
                    if [ "$current_sha_digest" != "$latest_sha_digest" ]; then
                      echo "üîÑ Base image has updates: $latest_sha_digest vs $current_sha_digest"
                      echo "Adding '$base_name' to rebuild list (vulnerabilities found + outdated base image)"
                      needs_rebuild_list="${needs_rebuild_list} ${base_name}"
                      rebuild_reason="Fixable vulnerabilities found and base image $from_image_name has updates."
                    else
                      echo "‚úÖ Base image [$from_image_name] is up-to-date. Skipping rebuild despite vulnerabilities."
                      rebuild_reason="Fixable vulnerabilities found, but base image $from_image_name is already up-to-date."
                    fi
                  else
                    echo "::warning::Could not extract latest digest from manifest for [$from_image_name]. Skipping rebuild."
                    rebuild_reason="Fixable vulnerabilities found, but could not determine latest base image digest."
                  fi
                else
                  echo "::warning::Failed to inspect manifest for base image [$from_image_name]. Skipping rebuild."
                  rebuild_reason="Fixable vulnerabilities found, but failed to inspect base image $from_image_name."
                fi
              else
                echo "::error::Could not parse FROM line components in $dockerfile. Line was: '$from_line'"
                rebuild_reason="Fixable vulnerabilities found, but could not parse FROM line in $dockerfile."
              fi
            else
              echo "‚úÖ No fixable vulnerabilities found for $base_name"
              rebuild_reason="No fixable vulnerabilities found."
            fi

            if dockerfile_has_changed "$base_name"; then
              echo "Dockerfile.$base_name has changed since its last release."
              needs_rebuild_list="${needs_rebuild_list} ${base_name}"
              rebuild_reason="Dockerfile has unreleased changes."
            fi

            echo "Decision for $base_name: $rebuild_reason"
          done # End base_name loop

          # Process rebuild list
          unique_needs_rebuild=$(echo "$needs_rebuild_list" | xargs -n1 | sort -u | xargs)

          if [ -z "$unique_needs_rebuild" ]; then
            echo "‚úÖ No images require rebuilding based on vulnerability scans and base image freshness checks."
            echo "triggered_rebuilds=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "üöÄ Triggering rebuilds for: $unique_needs_rebuild"
          echo "triggered_rebuilds=true" >> $GITHUB_OUTPUT
          echo "rebuild_list=$unique_needs_rebuild" >> $GITHUB_OUTPUT

          # Configure git for creating tags
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          for base_name in $unique_needs_rebuild; do
            echo "Creating rebuild tag for $base_name..."

            # Find latest release tag
            latest_release_tag=$(git tag --list "release/${base_name}/v*" | sort -V | tail -n 1)

            if [ -z "$latest_release_tag" ]; then
              echo "::error::Could not find any release tag matching 'release/${base_name}/v*' to base the rebuild on. Skipping rebuild trigger for $base_name."
              continue
            fi
            echo "Latest release tag found: $latest_release_tag"

            # COOLDOWN CHECK: Skip if recently rebuilt (unless force or critical)
            if [ "${{ github.event.inputs.ignore_cooldown }}" != "true" ]; then
              # Get the commit timestamp of the latest tag
              tag_commit=$(git rev-list -n 1 "$latest_release_tag")
              tag_timestamp=$(git show -s --format=%ct "$tag_commit")
              current_timestamp=$(date +%s)
              hours_since_last_release=$(( (current_timestamp - tag_timestamp) / 3600 ))

              cooldown_hours="${REBUILD_COOLDOWN_HOURS:-72}"

              echo "‚è±Ô∏è  Hours since last release for $base_name: $hours_since_last_release (cooldown: ${cooldown_hours}h)"

              if [ "$hours_since_last_release" -lt "$cooldown_hours" ]; then
                echo "‚è∏Ô∏è  Skipping $base_name: Within ${cooldown_hours}h cooldown period"
                echo "   Last release: $(date -d @${tag_timestamp} 2>/dev/null || date -r ${tag_timestamp})"
                echo "   Next eligible: $(date -d @$((tag_timestamp + cooldown_hours * 3600)) 2>/dev/null || date -r $((tag_timestamp + cooldown_hours * 3600)))"
                continue
              else
                echo "‚úÖ $base_name passed cooldown check (${hours_since_last_release}h > ${cooldown_hours}h)"
              fi
            else
              echo "‚ö†Ô∏è  Cooldown check skipped (ignore_cooldown=true)"
            fi

            # Extract version and create rebuild tag
            version_part=$(echo "$latest_release_tag" | sed -n "s|release/${base_name}/\(v.*\)|\1|p")
            if [ -z "$version_part" ]; then
              echo "::error::Could not extract version part from tag '$latest_release_tag'. Skipping rebuild for $base_name."
              continue
            fi

            # Create rebuild tag with timestamp
            timestamp=$(date +%Y%m%d%H%M%S)
            version_part_no_build=$(echo "$version_part" | sed 's/\+.*//')
            new_tag="release/${base_name}/${version_part_no_build}+rebuild.${timestamp}"

            echo "Creating and pushing rebuild tag: $new_tag"
            git tag "$new_tag"
            git push origin "$new_tag"
            echo "‚úÖ Rebuild triggered for $base_name by pushing tag $new_tag"
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
