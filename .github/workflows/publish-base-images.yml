# .github/workflows/publish-base-images.yml
name: Publish Base Docker images

on:
  push:
    tags:
      - "release/**"
    branches:
      - main
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  TAG: ${{ github.ref }}

jobs:
  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      image-base-name: ${{ steps.context.outputs.image-base-name }}
      is_deprecated: ${{ steps.image_deprecation_check.outputs.is_deprecated }}
      tag: ${{ steps.set-tag.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0 # Needed for git diff in PRs

      - name: Set Tag and Detect Image for PR
        id: set-tag
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            modified_dockerfile=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep "^Dockerfile\\." | head -n 1)
            if [ -n "$modified_dockerfile" ]; then
              detected_image=$(echo "$modified_dockerfile" | sed 's/^Dockerfile\.//')
              if [[ "$detected_image" == "go-base" || "$detected_image" == "nodejs-base" || "$detected_image" == "python-base" ]]; then
                echo "PR modifies a deprecated image ($detected_image). Halting build for this image."
                echo "dockerfile_found=false" >> $GITHUB_OUTPUT
                echo "tag=${{ github.ref }}" >> $GITHUB_OUTPUT
              else
                detected_tag="release/${detected_image}/v0.0.0-pr"
                echo "dockerfile_found=true" >> $GITHUB_OUTPUT
                echo "tag=$detected_tag" >> $GITHUB_OUTPUT
                echo "Detected image from PR: $detected_image, using tag: $detected_tag"
              fi
            else
              echo "dockerfile_found=false" >> $GITHUB_OUTPUT
              echo "tag=${{ github.ref }}" >> $GITHUB_OUTPUT
              echo "No Dockerfile changes detected in PR, will exit early"
            fi
          else
            echo "dockerfile_found=true" >> $GITHUB_OUTPUT
            echo "tag=${{ github.ref }}" >> $GITHUB_OUTPUT
          fi

      - name: Parse image context
        id: context
        uses: ./.github/actions/parse-image-context
        with:
          tag: ${{ steps.set-tag.outputs.tag }}
          platform: "linux/amd64"

      - name: Check for deprecated image after parsing
        id: image_deprecation_check
        run: |
           if [ "${{ steps.context.outputs.image-base-name }}" == "__UNDEFINED__" ]; then
             echo "Deprecated or invalid image detected for tag ${{ steps.set-tag.outputs.tag }}. Skipping build."
             echo "is_deprecated=true" >> $GITHUB_OUTPUT
           else
             echo "is_deprecated=false" >> $GITHUB_OUTPUT
           fi

  publish_image:
    needs: generate-matrix
    if: needs.generate-matrix.outputs.is_deprecated != 'true'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.context.outputs.version }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      TAG: ${{ needs.generate-matrix.outputs.tag }}
    strategy:
      fail-fast: false
      matrix:
        platform: [linux/amd64, linux/arm64]
    permissions:
      contents: write
      packages: write
      security-events: write
      actions: read
      attestations: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Parse image context
        id: context
        uses: ./.github/actions/parse-image-context
        with:
          tag: ${{ env.TAG }}
          platform: ${{ matrix.platform }}

      - name: Check if Dockerfile exists
        id: file_check
        run: |
          dockerfile_path="Dockerfile.${{ needs.generate-matrix.outputs.image-base-name }}"
          if [ -f "$dockerfile_path" ]; then
            echo "dockerfile_exists=true" >> $GITHUB_OUTPUT
          else
            echo "dockerfile_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Exit early if Dockerfile does not exist
        if: steps.file_check.outputs.dockerfile_exists != 'true'
        run: |
          echo "Dockerfile for ${{ needs.generate-matrix.outputs.image-base-name }} does not exist. Halting build."
          exit 0

      - name: Check if Dockerfile changed for this image
        id: dockerfile_check
        run: |
          if [[ "${{ github.event_name }}" != "push" || "${{ github.ref_type }}" != "tag" ]]; then
            echo "dockerfile_changed=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          dockerfile_path="Dockerfile.${{ needs.generate-matrix.outputs.image-base-name }}"
          prev_tag=$(git tag -l "release/${{ needs.generate-matrix.outputs.image-base-name }}/v*" --sort=-version:refname | head -n 2 | tail -n 1)
          if [ -n "$prev_tag" ]; then
            if git diff --name-only "$prev_tag" HEAD | grep -q "^${dockerfile_path}$"; then
              echo "dockerfile_changed=true" >> $GITHUB_OUTPUT
            else
              echo "dockerfile_changed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "dockerfile_changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Exit early if Dockerfile unchanged
        if: steps.dockerfile_check.outputs.dockerfile_changed != 'true'
        run: |
          echo "Did not detect any modified Dockerfiles in this commit, exiting."
          exit 0

      - name: Check if image already exists for this tag
        if: github.event_name == 'push' && github.ref_type == 'tag'
        id: image_exists
        run: |
          image_name="${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}"
          tag="${{ steps.context.outputs.version }}"
          if docker manifest inspect "$image_name:$tag" >/dev/null 2>&1; then
            echo "image_exists=true" >> $GITHUB_OUTPUT
          else
            echo "image_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Exit early if image already published
        if: github.event_name == 'push' && github.ref_type == 'tag' && steps.image_exists.outputs.image_exists == 'true'
        run: |
          echo "Image already published for this tag, skipping build."
          exit 0

      - name: Setup Docker environment
        uses: ./.github/actions/setup-docker
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          platform: ${{ matrix.platform }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}
          tags: |
            type=raw,value=${{ steps.context.outputs.version }},enable=${{ github.ref_type == 'tag' }}
            type=raw,value=latest,enable=${{ github.ref_type == 'tag' }}
            type=raw,value=test,enable=${{ github.event_name == 'pull_request' }}
          labels: |
            org.opencontainers.image.title=${{ steps.context.outputs.image-name }}
            org.opencontainers.image.description=Hardened base image for ${{ needs.generate-matrix.outputs.image-base-name }}
            org.opencontainers.image.vendor=InterruptZero.io
            org.opencontainers.image.version=${{ steps.context.outputs.version }}

      - name: Build Docker Image for ${{ matrix.platform }}
        id: build
        uses: docker/build-push-action@v6
        with:
          pull: true
          file: Dockerfile.${{ needs.generate-matrix.outputs.image-base-name }}
          platforms: ${{ matrix.platform }}
          load: true
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          provenance: false
          sbom: false
          cache-from: type=gha,scope=${{ github.repository }}-${{ needs.generate-matrix.outputs.image-base-name }}
          cache-to: type=gha,mode=max,scope=${{ github.repository }}-${{ needs.generate-matrix.outputs.image-base-name }}

      - name: Set test image reference
        id: test_image
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "image_ref=${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}:test" >> $GITHUB_OUTPUT
          else
            echo "image_ref=${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}:${{ steps.context.outputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Output Docker Image Size for ${{ matrix.platform }}
        run: |
          size=$(docker images --format "table {{.Size}}" "${{ steps.test_image.outputs.image_ref }}" | tail -n +2)
          echo "Docker image size for ${{ matrix.platform }}: $size"

      - name: Cache container-structure-test
        id: cst-cache
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/container-structure-test
          key: cst-${{ runner.os }}-latest

      - name: Install container-structure-test
        if: steps.cst-cache.outputs.cache-hit != 'true'
        run: |
          curl -LO https://storage.googleapis.com/container-structure-test/latest/container-structure-test-linux-amd64
          chmod +x container-structure-test-linux-amd64
          sudo mv container-structure-test-linux-amd64 /usr/local/bin/container-structure-test

      - name: Run Container Structure Tests for ${{ matrix.platform }}
        run: |
          image_base_name="${{ needs.generate-matrix.outputs.image-base-name }}"
          test_config="tests/container-structure/${image_base_name}.yaml"
          if [ -f "$test_config" ]; then
            container-structure-test test --image "${{ steps.test_image.outputs.image_ref }}" --config "$test_config"
          else
            echo "No container structure test config found at $test_config, skipping tests"
          fi

      - name: Run Trivy vulnerability scanner for ${{ matrix.platform }}
        uses: aquasecurity/trivy-action@c1824fd6edce30d7ab345a9989de00bbd46ef284
        with:
          scan-type: image
          image-ref: ${{ steps.test_image.outputs.image_ref }}
          format: table
          exit-code: "1"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH,MEDIUM"

      # Push image only after all tests and security scans pass
      - name: Push Docker Image for ${{ matrix.platform }}
        id: push
        if: github.event_name == 'push' && github.ref_type == 'tag'
        uses: docker/build-push-action@v6
        with:
          file: Dockerfile.${{ needs.generate-matrix.outputs.image-base-name }}
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          provenance: mode=max
          sbom: true
          cache-from: type=gha,scope=${{ github.repository }}-${{ needs.generate-matrix.outputs.image-base-name }}

      - name: Install cosign
        if: github.event_name == 'push' && github.ref_type == 'tag'
        uses: sigstore/cosign-installer@v3

      - name: Sign container image with cosign
        if: github.event_name == 'push' && github.ref_type == 'tag'
        env:
          DIGEST: ${{ steps.push.outputs.digest }}
          TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          images=""
          for tag in ${TAGS}; do
            images+="${tag}@${DIGEST} "
          done
          cosign sign --yes ${images}

      - name: Generate artifact attestation
        if: github.event_name == 'push' && github.ref_type == 'tag'
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ${{ env.REGISTRY }}/${{ github.repository }}/${{ steps.context.outputs.image-name }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

      - name: Extract language versions
        id: extract_versions
        uses: ./.github/actions/extract-versions
        with:
          image-base-name: ${{ needs.generate-matrix.outputs.image-base-name }}
          image-tag: ${{ steps.test_image.outputs.image_ref }}
          platform: ${{ matrix.platform }}
          platform-suffix: ${{ steps.context.outputs.platform-suffix }}

      - name: Upload versions artifact for ${{ matrix.platform }}
        if: steps.extract_versions.outputs.extraction-success == 'true' && github.event_name == 'push' && github.ref_type == 'tag'
        uses: actions/upload-artifact@v6
        with:
          name: versions-file-${{ steps.context.outputs.platform-suffix }}
          path: ${{ steps.extract_versions.outputs.versions-file }}
          retention-days: 1
          if-no-files-found: error

  create_release:
    needs: [generate-matrix, publish_image]
    if: "github.event_name == 'push' && github.ref_type == 'tag' && needs.generate-matrix.outputs.is_deprecated != 'true'"
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Parse tag for release info
        id: parse_tag_release
        uses: ./.github/actions/parse-image-context
        with:
          tag: ${{ needs.generate-matrix.outputs.tag }}
          platform: linux/amd64

      - name: Download artifacts
        uses: actions/download-artifact@v7
        continue-on-error: true
        with:
          path: artifacts/
          pattern: versions-file-*

      - name: Create GitHub Release Body
        id: release_body
        run: |
          image_base_name="${{ needs.generate-matrix.outputs.image-base-name }}"
          version_tag="${{ needs.publish_image.outputs.version }}"
          repo_name="${{ github.repository }}"
          registry="${{ env.REGISTRY }}"

          # Use a temporary file to construct the body
          RELEASE_BODY_FILE="$(mktemp)"

          cat > "$RELEASE_BODY_FILE" << EOF
          Platform-specific Docker images for \`$image_base_name\` version \`$version_tag\` pushed.

          **We strongly recommend using the \`:latest\` tag for all images.** This ensures you always have the most recent security patches and updates.
          To ensure your CI/CD pipeline always uses the latest version of the image, you should use the \`--pull\` flag in your \`docker build\` command.

          **Published Images & Tags:**

          \\*   **linux/amd64:**
              \\*   Image: \`${registry}/${repo_name}/${image_base_name}-linux-amd64\`
              \\*   Tag: \`${version_tag}\`
              \\*   Tag: \`latest\`
          \\*   **linux/arm64:**
              \\*   Image: \`${registry}/${repo_name}/${image_base_name}-linux-arm64\`
              \\*   Tag: \`${version_tag}\`
              \\*   Tag: \`latest\`

          **Dockerfile Example:**
          \`\`\`dockerfile
          FROM ${registry}/${repo_name}/${image_base_name}:latest
          \`\`\`

          **Pull Example:**
          \`\`\`bash
          docker pull ${registry}/${repo_name}/${image_base_name}:latest
          \`\`\`

          **Build command:**
          \`\`\`bash
          docker build --pull -t your-app .
          \`\`\`

          **üîê Build Provenance & Supply Chain Security:**

          Platform-specific images include full SLSA provenance attestations (\`provenance: mode=max\`) and SBOM.

          **Verify image signatures (cosign):**
          \`\`\`bash
          # AMD64
          cosign verify \\
            --certificate-identity-regexp "https://github.com/${repo_name}/.github/workflows/.*" \\
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \\
            ${registry}/${repo_name}/${image_base_name}-linux-amd64:latest

          # ARM64
          cosign verify \\
            --certificate-identity-regexp "https://github.com/${repo_name}/.github/workflows/.*" \\
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \\
            ${registry}/${repo_name}/${image_base_name}-linux-arm64:latest
          \`\`\`

          **Verify with GitHub CLI:**
          \`\`\`bash
          # AMD64
          gh attestation verify oci://${registry}/${repo_name}/${image_base_name}-linux-amd64:latest \\
            -R ${repo_name}

          # ARM64
          gh attestation verify oci://${registry}/${repo_name}/${image_base_name}-linux-arm64:latest \\
            -R ${repo_name}
          \`\`\`

          **Inspect SLSA provenance:**
          \`\`\`bash
          docker buildx imagetools inspect ${registry}/${repo_name}/${image_base_name}-linux-amd64:latest \\
            --format "{{json .Provenance}}"
          \`\`\`
          EOF

          body_content=$(<"$RELEASE_BODY_FILE")
          echo "Setting BODY_TEXT environment variable..."
          echo "BODY_TEXT<<EOF" >> $GITHUB_ENV
          echo "$body_content" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          rm -f "$RELEASE_BODY_FILE" # Clean up temporary file


      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: "Release ${{ needs.generate-matrix.outputs.image-base-name }} ${{ steps.parse_tag_release.outputs.version }}"
          body: ${{ env.BODY_TEXT }}
          draft: false
          prerelease: ${{ contains(steps.parse_tag_release.outputs.version, '-') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create_multiarch_manifests:
    needs: [generate-matrix, publish_image, create_release]
    if: "github.event_name == 'push' && github.ref_type == 'tag' && needs.generate-matrix.outputs.is_deprecated != 'true'"
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Create multi-arch manifests
        run: |
          image_base_name="${{ needs.generate-matrix.outputs.image-base-name }}"
          version="${{ needs.publish_image.outputs.version }}"
          registry="${{ env.REGISTRY }}/${{ github.repository }}"
          
          echo "Creating multi-arch manifests for $image_base_name"
          
          # Base images for manifest creation
          amd64_image="$registry/$image_base_name-linux-amd64"
          arm64_image="$registry/$image_base_name-linux-arm64"
          universal_image="$registry/$image_base_name"
          
          echo "Checking if source images exist:"
          echo "AMD64: $amd64_image:$version"
          docker manifest inspect "$amd64_image:$version" >/dev/null && echo "‚úÖ AMD64 image exists" || echo "‚ùå AMD64 image missing"
          echo "ARM64: $arm64_image:$version"
          docker manifest inspect "$arm64_image:$version" >/dev/null && echo "‚úÖ ARM64 image exists" || echo "‚ùå ARM64 image missing"
          
          echo "AMD64: $amd64_image:latest"
          docker manifest inspect "$amd64_image:latest" >/dev/null && echo "‚úÖ AMD64 latest exists" || echo "‚ùå AMD64 latest missing"
          echo "ARM64: $arm64_image:latest"
          docker manifest inspect "$arm64_image:latest" >/dev/null && echo "‚úÖ ARM64 latest exists" || echo "‚ùå ARM64 latest missing"
          
          # Get digests for specific platforms
          echo "Getting platform-specific digests..."
          amd64_digest=$(docker manifest inspect "$amd64_image:$version" | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest')
          arm64_digest=$(docker manifest inspect "$arm64_image:$version" | jq -r '.manifests[] | select(.platform.architecture=="arm64") | .digest')
          
          amd64_latest_digest=$(docker manifest inspect "$amd64_image:latest" | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest')
          arm64_latest_digest=$(docker manifest inspect "$arm64_image:latest" | jq -r '.manifests[] | select(.platform.architecture=="arm64") | .digest')
          
          echo "AMD64 version digest: $amd64_digest"
          echo "ARM64 version digest: $arm64_digest"
          echo "AMD64 latest digest: $amd64_latest_digest"
          echo "ARM64 latest digest: $arm64_latest_digest"
          
          # Create unified manifest for semver version using digests
          echo "Creating manifest for $universal_image:$version"
          docker manifest create "$universal_image:$version" \
            "$amd64_image@$amd64_digest" \
            "$arm64_image@$arm64_digest" || \
          docker manifest create --amend "$universal_image:$version" \
            "$amd64_image@$amd64_digest" \
            "$arm64_image@$arm64_digest"
          docker manifest push "$universal_image:$version"
          
          # Create unified manifest for latest using digests
          echo "Creating manifest for $universal_image:latest"
          docker manifest create "$universal_image:latest" \
            "$amd64_image@$amd64_latest_digest" \
            "$arm64_image@$arm64_latest_digest" || \
          docker manifest create --amend "$universal_image:latest" \
            "$amd64_image@$amd64_latest_digest" \
            "$arm64_image@$arm64_latest_digest"
          docker manifest push "$universal_image:latest"
          
          # Create version-specific manifests if available
          if [[ "${{ needs.publish_image.outputs.version_tags.has_version_tags }}" == "true" ]]; then
            major_tag="${{ needs.publish_image.outputs.version_tags.major_tag }}"
            minor_tag="${{ needs.publish_image.outputs.version_tags.minor_tag }}"
            
            if [[ -n "$major_tag" ]]; then
              echo "Creating manifest for $universal_image:$major_tag"
              # Get digests for major tag
              major_amd64_digest=$(docker manifest inspect "$amd64_image:$major_tag" | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest')
              major_arm64_digest=$(docker manifest inspect "$arm64_image:$major_tag" | jq -r '.manifests[] | select(.platform.architecture=="arm64") | .digest')
              
              docker manifest create "$universal_image:$major_tag" \
                "$amd64_image@$major_amd64_digest" \
                "$arm64_image@$major_arm64_digest" || \
              docker manifest create --amend "$universal_image:$major_tag" \
                "$amd64_image@$major_amd64_digest" \
                "$arm64_image@$major_arm64_digest"
              docker manifest push "$universal_image:$major_tag"
            fi
            
            if [[ -n "$minor_tag" ]]; then
              echo "Creating manifest for $universal_image:$minor_tag"
              # Get digests for minor tag  
              minor_amd64_digest=$(docker manifest inspect "$amd64_image:$minor_tag" | jq -r '.manifests[] | select(.platform.architecture=="amd64") | .digest')
              minor_arm64_digest=$(docker manifest inspect "$arm64_image:$minor_tag" | jq -r '.manifests[] | select(.platform.architecture=="arm64") | .digest')
              
              docker manifest create "$universal_image:$minor_tag" \
                "$amd64_image@$minor_amd64_digest" \
                "$arm64_image@$minor_arm64_digest" || \
              docker manifest create --amend "$universal_image:$minor_tag" \
                "$amd64_image@$minor_amd64_digest" \
                "$arm64_image@$minor_arm64_digest"
              docker manifest push "$universal_image:$minor_tag"
            fi
          fi
          
          echo "‚úÖ Multi-arch manifests created successfully"

      - name: Verify multi-arch manifests
        run: |
          image_base_name="${{ needs.generate-matrix.outputs.image-base-name }}"
          version="${{ needs.publish_image.outputs.version }}"
          registry="${{ env.REGISTRY }}/${{ github.repository }}"
          universal_image="$registry/$image_base_name"
          
          echo "Verifying multi-arch manifests:"
          
          # Verify semver and latest tags
          for tag in "$version" "latest"; do
            echo "Checking $universal_image:$tag"
            docker manifest inspect "$universal_image:$tag" | jq '.manifests[].platform'
          done
          
          # Verify version tags if they exist
          if [[ "${{ needs.publish_image.outputs.version_tags.has_version_tags }}" == "true" ]]; then
            major_tag="${{ needs.publish_image.outputs.version_tags.major_tag }}"
            minor_tag="${{ needs.publish_image.outputs.version_tags.minor_tag }}"
            
            for tag in "$major_tag" "$minor_tag"; do
              if [[ -n "$tag" ]]; then
                echo "Checking $universal_image:$tag"
                docker manifest inspect "$universal_image:$tag" | jq '.manifests[].platform'
              fi
            done
          fi